<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>treemaps &#8211; jckr.github.io/blog</title>
	<atom:link href="http://localhost/tag/treemaps/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>Just another WordPress site</description>
	<lastBuildDate>Wed, 17 Aug 2016 05:36:39 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.10</generator>
	<item>
		<title>Treemaps in Tableau? can be done.</title>
		<link>/2012/04/19/treemaps-in-tableau-can-be-done/</link>
		<comments>/2012/04/19/treemaps-in-tableau-can-be-done/#comments</comments>
		<pubDate>Thu, 19 Apr 2012 11:16:13 +0000</pubDate>
		<dc:creator><![CDATA[jerome]]></dc:creator>
				<category><![CDATA[d3]]></category>
		<category><![CDATA[tips]]></category>
		<category><![CDATA[Tableau]]></category>
		<category><![CDATA[treemaps]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">http://jckr.github.io/blog/?p=1211</guid>
		<description><![CDATA[Tableau can do many things natively but there are a couple of basic primitives that are not built in because they behave somewhat differently from the overall logic. And treemaps is one of them. Then again treemaps are arguably one of the best way to express complex hierarchical information, i.e. to show the proportions in <a class="read-more" href="/blog/2012/04/19/treemaps-in-tableau-can-be-done/">&#8230;&#160;<span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[Tableau can do many things natively but there are a couple of basic primitives that are not built in because they behave somewhat differently from the overall logic. And <a href="http://www.tableausoftware.com/about/blog/2011/05/alternative-tree-maps-0">treemaps is one of them</a>. Then again treemaps are arguably one of the best way to express complex hierarchical information, i.e. to show the proportions in a large dataset.</p>

Fortunately, thanks to Tableau flexibility there are ways to do that. In the tutorial I'm going to cover 2 cases. First, we'll create a somewhat complex treemap off data which will not change in runtime. Then, we'll create mini-treemaps which can change dynamically.</p>
<h2>A complex treemap</h2>
<script type="text/javascript" src="http://public.tableausoftware.com/javascripts/api/viz_v1.js"></script>
<noscript><a href="#"><img alt="ComplexTM " src="http:&#47;&#47;public.tableausoftware.com&#47;static&#47;images&#47;tr&#47;treemaps&#47;ComplexTM&#47;1_rss.png" style="border: none" /></a></noscript><object class="tableauViz" width="604" height="369" style="display:none;"><param name="host_url" value="http%3A%2F%2Fpublic.tableausoftware.com%2F" /><param name="site_root" value="" /><param name="name" value="treemaps&#47;ComplexTM" /><param name="tabs" value="no" /><param name="toolbar" value="yes" /><param name="static_image" value="http:&#47;&#47;public.tableausoftware.com&#47;static&#47;images&#47;tr&#47;treemaps&#47;ComplexTM&#47;1.png" /><param name="animate_transition" value="yes" /><param name="display_static_image" value="yes" /><param name="display_spinner" value="yes" /><param name="display_overlay" value="yes" /><param name="display_count" value="yes" /></object>
<div style="width:604px;height:22px;padding:0px 10px 0px 0px;color:black;font:normal 8pt verdana,helvetica,arial,sans-serif;"><div style="float:right; padding-right:8px;"><a href="http://www.tableausoftware.com/public?ref=http://public.tableausoftware.com/views/treemaps/ComplexTM" target="_blank">Powered by Tableau</a></div></div>
Before we go in the details the main ideas are deceptively simple.</p>
<ul>
	<li>we use the polygon mark,</li>
	<li>we generate the treemap layout outside of tableau.</li>
</ul>
What we want (and what we'll get) is a dataset that can be directly imported in Tableau and -boom- makes a treemap in a few clicks.</p>

To make this dataset we can use d3. The treemap I am making is directly inspired from the <a href="mbostock.github.com/d3/ex/treemap.html">d3 treemap example</a>. d3 is already computing all of the node positions so what we'll do is modify the program slightly so that it outputs them in a way that can be directly used in Tableau.</p>

Here is the <a href="http://jckr.github.io/blog/wp-content/uploads/2012/04/treemap.html">modified file</a> which you can download and run on your computer. To work it needs to be in the same folder as a <a href="http://jckr.github.io/blog/wp-content/uploads/2012/04/data.js">data file</a> called data.js which will hold your hiearchical data and which has the same structure as the one linked here.</p>

You can just copy/paste the table that's displayed below the treemap and put it in Tableau or save it in a file for good measure. Here is <a href="http://jckr.github.io/blog/wp-content/uploads/2012/04/data.csv">the output</a> of the data file linked above.</p>

Let's take a look at a few rows :</p>
<table>
<tbody>
<tr>
<td>Id</td>
<td>Path</td>
<td>Top-level category</td>
<td>Name</td>
<td>Value</td>
<td>Corner</td>
<td>x</td>
<td>y</td>
</tr>
<tr>
<td>0</td>
<td>flare&gt;analytics&gt;cluster</td>
<td>flare</td>
<td>AgglomerativeCluster</td>
<td>3938</td>
<td>0</td>
<td>89</td>
<td>167</td>
</tr>
<tr>
<td>0</td>
<td>flare&gt;analytics&gt;cluster</td>
<td>flare</td>
<td>AgglomerativeCluster</td>
<td>3938</td>
<td>1</td>
<td>167</td>
<td>167</td>
</tr>
<tr>
<td>0</td>
<td>flare&gt;analytics&gt;cluster</td>
<td>flare</td>
<td>AgglomerativeCluster</td>
<td>3938</td>
<td>2</td>
<td>167</td>
<td>192</td>
</tr>
<tr>
<td>0</td>
<td>flare&gt;analytics&gt;cluster</td>
<td>flare</td>
<td>AgglomerativeCluster</td>
<td>3938</td>
<td>3</td>
<td>89</td>
<td>192</td>
</tr>
<tr>
<td>1</td>
<td>flare&gt;analytics&gt;cluster</td>
<td>flare</td>
<td>CommunityStructure</td>
<td>3812</td>
<td>0</td>
<td>102</td>
<td>138</td>
</tr>
<tr>
<td>1</td>
<td>flare&gt;analytics&gt;cluster</td>
<td>flare</td>
<td>CommunityStructure</td>
<td>3812</td>
<td>1</td>
<td>167</td>
<td>138</td>
</tr>
<tr>
<td>1</td>
<td>flare&gt;analytics&gt;cluster</td>
<td>flare</td>
<td>CommunityStructure</td>
<td>3812</td>
<td>2</td>
<td>167</td>
<td>167</td>
</tr>
<tr>
<td>1</td>
<td>flare&gt;analytics&gt;cluster</td>
<td>flare</td>
<td>CommunityStructure</td>
<td>3812</td>
<td>3</td>
<td>102</td>
<td>167</td>
</tr>
<tr>
<td>2</td>
<td>flare&gt;analytics&gt;cluster</td>
<td>flare</td>
<td>HierarchicalCluster</td>
<td>6714</td>
<td>0</td>
<td>89</td>
<td>192</td>
</tr>
<tr>
<td>2</td>
<td>flare&gt;analytics&gt;cluster</td>
<td>flare</td>
<td>HierarchicalCluster</td>
<td>6714</td>
<td>1</td>
<td>167</td>
<td>192</td>
</tr>
<tr>
<td>2</td>
<td>flare&gt;analytics&gt;cluster</td>
<td>flare</td>
<td>HierarchicalCluster</td>
<td>6714</td>
<td>2</td>
<td>167</td>
<td>236</td>
</tr>
<tr>
<td>2</td>
<td>flare&gt;analytics&gt;cluster</td>
<td>flare</td>
<td>HierarchicalCluster</td>
<td>6714</td>
<td>3</td>
<td>89</td>
<td>236</td>
</tr>
</tbody>
</table>
I'm creating 4 lines per "leaf" node. So in this example which has 220 nodes, that amounts to 880 lines. Why 4? Because to draw a rectangle in Tableau you really need to define 4 corners. This is why there is a column "Corner" which is worth 0,1,2 and 3. This, we will use to tell Tableau to read our corners in bottom left, bottom right, top right, top left order which produces a nice convex rectangle and not a concave hourglass shape.</p>

Now off to Tableau with this data. <a href="http://jckr.github.io/blog/wp-content/uploads/2012/04/complex.png"><img class="aligncenter size-full wp-image-1212" title="complex" src="https://jckr.github.io/blog/wp-content/uploads/2012/04/complex.png" alt="" width="558" height="477" /></a></p>

Now it's just a matter of doing like this screen. Unsurprisingly the columns and rows are going to be determined by x and y. You want a polygon mark, and you absolutely must use your corner measure in the path. For color, you'll have a choice, you can use the top-level category column (as I have) or the full path which will divide your treemap in finer parts. Finally, level of detail: you must use the Id and not the name in case several of your nodes have the same name. It's quite important at this point to uncheck aggregate measures in Analysis. You do NOT want aggregate measures (though it's quite pretty). To be able to use the name, you must first make a measure out of it. And finally, you'll want to update your infotip slightly.</p>

All of this you can see if you download the tableau file.</p>

And voilà! Treemaps for your Tableau workbooks.</p>

<em>Caveat:</em> the polygon mark doesn't support labels so you can't write on top of the small rectangles what they are but that's not the point of the treemap, which is instead to give an immediate first impression of the relative size of large groups of your data, then allow you to explore them, to that end the infotip function works just fine.</p>
<h2>Simpler but dynamic treemaps</h2>
This is fine and dandy if your data doesn't change but it won't scale if you need to make many treemaps based on selections. What to do? You could use pie charts, but let's not.</p>

To that end I've tried to emulate the <a href="http://www.congressspeaks.com/">Congress speaks</a> visualization by <a href="http://periscopic.com/">Periscopic</a>. I really like it. When you've selected representatives at the end of the process you are taken to a screen which shows the following mini-treemap:</p>

<a href="http://jckr.github.io/blog/wp-content/uploads/2012/04/votingrecord.png"><img class="aligncenter size-full wp-image-1213" title="votingrecord" src="https://jckr.github.io/blog/wp-content/uploads/2012/04/votingrecord.png" alt="" width="246" height="166" /></a></p>

There are just 5 rectangles. But they will change for any representative that we choose. Can this be done with Tableau? Obviously.</p>

Now the Tableau part of this is slightly trickier than above. The idea is that we are going to use formulas to generate the coordinates of all 20 corners of the rectangles, in other words we are going to let Tableau calculate the layout. We can do it because the way that rectangles are going to be arranged is quite predictible. There is one on the left, then 4 stacked on the right one on top of the other. Again, we could compute all of these coordinates outside of Tableau but that would be a hassle and so for a large number of cases it becomes easier and more reliable to do this inside of Tableau.</p>
<h3>Data</h3>
For this I have used completely random data. I have <a href="http://www.kleimo.com/random/name.cfm">generated 20 names</a>, and for each I have generated 5 values in a likely range, number of possible votes, number of votes the representative actually voted, number of times they voted yes, number of times they voted yes with their party, and the same for no. (or nay, technically).</p>

At the end of the day I need 20 records per representative (5 rectangles of 4 corners each), so I can either replicate the line 20 times, or use linked tables. The idea is to get something like this for all of the representatives that can somehow get into Tableau.</p>
<table width="640" border="0" cellspacing="0" cellpadding="0"><colgroup> <col span="10" width="64" /> </colgroup>
<tbody>
<tr>
<td width="64" height="17">Id</td>
<td width="64">representative</td>
<td width="64">corner</td>
<td width="64">rectangle</td>
<td width="64">possible votes</td>
<td width="64">total votes</td>
<td width="64">voted yes</td>
<td width="64">yes with party</td>
<td width="64">voted no</td>
<td width="64">no with party</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">0</td>
<td>no against party</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">1</td>
<td>no against party</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">2</td>
<td>no against party</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">3</td>
<td>no against party</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">0</td>
<td>no vote</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">1</td>
<td>no vote</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">2</td>
<td>no vote</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">3</td>
<td>no vote</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">0</td>
<td>no with party</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">1</td>
<td>no with party</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">2</td>
<td>no with party</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">3</td>
<td>no with party</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">0</td>
<td>yes against party</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">1</td>
<td>yes against party</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">2</td>
<td>yes against party</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">3</td>
<td>yes against party</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">0</td>
<td>yes with party</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">1</td>
<td>yes with party</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">2</td>
<td>yes with party</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
<tr>
<td align="right" height="17">16</td>
<td>Nelson Thiede</td>
<td align="right">3</td>
<td>yes with party</td>
<td align="right">888</td>
<td align="right">784</td>
<td align="right">320</td>
<td align="right">274</td>
<td align="right">464</td>
<td align="right">373</td>
</tr>
</tbody>
</table>
<h3>In Tableau</h3>
In Tableau we are going to use the same idea as above: polygon mark, disable aggregate measures, and use x and y for columns and rows.</p>

Only, x and y are going to be much more complex. Sorry about that. Well, not that complex but definitely longer.</p>

Here's x:</p>

<pre class="brush: plain; title: ; notranslate">

case [rectangle]
when &quot;no vote&quot; then
     case [corner]
       when 0 then 0
       when 1 then (([possible votes]-[total votes])/[possible votes])
       when 2 then (([possible votes]-[total votes])/[possible votes])
       when 3 then 0
     end
else
     case [corner]
       when 0 then (([possible votes]-[total votes])/[possible votes])
       when 1 then 1
       when 2 then 1
       when 3 then (([possible votes]-[total votes])/[possible votes])
   end
end

</pre>

Depending on the rectangle we are trying to draw we can find ourselves in one of two cases (hence the use of case).</p>

If we draw "no vote" then we are on the left of our vis. The left corners are on the leftmost side of the vis (hence value: 0) and the right corners correspond to the proportion of possible votes which where not cast by this representative, which we can compute as ([possible votes]-[total votes])/[possible votes].</p>

In the other case, we are drawing one of the 4 stacked rectangles, so the right corners are on the rightmost side of the vis (hence value: 1) and the left corners correspond to the value we just computed.</p>

And now, y:</p>

<pre class="brush: plain; title: ; notranslate">
case [rectangle]
when &quot;no vote&quot; then
case [corner]
when 0 then 0
when 1 then 0
when 2 then 1
when 3 then 1
end
when &quot;yes against party&quot; then
case [corner]
when 0 then 0
when 1 then 0
when 2 then (([voted yes]-[yes with party])/[total votes])
when 3 then (([voted yes]-[yes with party])/[total votes])
end
when &quot;yes with party&quot; then
case [corner]
when 0 then (([voted yes]-[yes with party])/[total votes])
when 1 then (([voted yes]-[yes with party])/[total votes])
when 2 then ((2*[voted yes]-[yes with party])/[total votes])
when 3 then ((2*[voted yes]-[yes with party])/[total votes])
end
when &quot;no with party&quot; then
case [corner]
when 0 then ((2*[voted yes]-[yes with party])/[total votes])
when 1 then ((2*[voted yes]-[yes with party])/[total votes])
when 2 then ((2*[voted yes]+[no with party]-[yes with party])/[total votes])
when 3 then ((2*[voted yes]+[no with party]-[yes with party])/[total votes])
end
when &quot;no against party&quot; then
case [corner]
when 0 then ((2*[voted yes]+[no with party]-[yes with party])/[total votes])
when 1 then ((2*[voted yes]+[no with party]-[yes with party])/[total votes])
when 2 then 1
when 3 then 1
end
end
</pre>

y is longer but this is the same general idea. For the "no vote" rectangle, the corners are either to the top or bottom of the vis. But for the other, we can predict where the rectangle will start and when it will end, as a proportion of the [possible votes] field. The values we want are going to be correspond to these proportions, plus that of all the rectangles below so we can achieve that stacked effect (as opposed to have all rectangles superimposed at the bottom of the vis). This is why I am entering the rectangles in stacking order. Each time, the bottom corners get the value of the top corners of the previous rectangle.</p>

Here is the final result:</p>

&nbsp;
<script type="text/javascript" src="http://public.tableausoftware.com/javascripts/api/viz_v1.js"></script>
<noscript><a href="#"><img alt="mini TM " src="http:&#47;&#47;public.tableausoftware.com&#47;static&#47;images&#47;B5&#47;B5PW2XJWX&#47;1_rss.png" style="border: none" /></a></noscript>
<object class="tableauViz" width="404" height="269" style="display:none;">
<param name="host_url" value="http%3A%2F%2Fpublic.tableausoftware.com%2F" />
<param name="path" value="shared&#47;B5PW2XJWX" />
<param name="toolbar" value="yes" />
<param name="static_image" value="http:&#47;&#47;public.tableausoftware.com&#47;static&#47;images&#47;B5&#47;B5PW2XJWX&#47;1.png" />
<param name="animate_transition" value="yes" />
<param name="display_static_image" value="yes" />
<param name="display_spinner" value="yes" />
<param name="display_overlay" value="yes" />
<param name="display_count" value="yes" />
</object>
<div style="width:404px;height:22px;padding:0px 10px 0px 0px;color:black;font:normal 8pt verdana,helvetica,arial,sans-serif;"><div style="float:right; padding-right:8px;"><a href="http://www.tableausoftware.com/public?ref=http://public.tableausoftware.com/shared/B5PW2XJWX" target="_blank">Powered by Tableau</a></div></div>]]></content:encoded>
			<wfw:commentRss>/2012/04/19/treemaps-in-tableau-can-be-done/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
		<item>
		<title>La france qui exporte</title>
		<link>/2011/02/18/la-france-qui-exporte/</link>
		<comments>/2011/02/18/la-france-qui-exporte/#comments</comments>
		<pubDate>Fri, 18 Feb 2011 18:10:38 +0000</pubDate>
		<dc:creator><![CDATA[jerome]]></dc:creator>
				<category><![CDATA[data visualization]]></category>
		<category><![CDATA[protovis]]></category>
		<category><![CDATA[exports]]></category>
		<category><![CDATA[france]]></category>
		<category><![CDATA[maps]]></category>
		<category><![CDATA[trade]]></category>
		<category><![CDATA[treemaps]]></category>

		<guid isPermaLink="false">http://jckr.github.io/blog/?p=661</guid>
		<description><![CDATA[This week, I was made aware of a new set of maps by French ministry of Foreign Trade, called cartographie de la France qui exporte (map of France exports) (link). Since I&#8217;m interested in the topic and that I know that French public services have killer cartographers I was eager to see what was so <a class="read-more" href="/blog/2011/02/18/la-france-qui-exporte/">&#8230;&#160;<span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>This week, I was made aware of a new set of maps by French ministry of Foreign Trade, called <em>cartographie de la France qui exporte</em> (map of France exports) (<a href="http://www.exporter.gouv.fr/exporter/Pages.aspx?iddoc=1821&#038;pex=1-2-40-926-1821">link</a>). Since I&#8217;m interested in the topic and that I know that French public services have killer cartographers I was eager to see what was so exciting about the first set of online maps on French exports. </p>
<p>I was a little underwhelmed to be honest. Online here meant static pdf files, although this is a dataset that just begs to be explored and manipulated.<br />
On top of that, those where basic choropleth maps with markers such as this one here:<br />
<a href="http://jckr.github.io/blog/wp-content/uploads/2011/02/largemap.png"><img src="https://jckr.github.io/blog/wp-content/uploads/2011/02/largemap.png" alt="" title="largemap" width="626" height="631" class="size-full wp-image-662" /></a></p>
<p>Now this map has two problems. First, it&#8217;s a choropleth with a discrete scale, but the values of adjacent areas can vary a lot. So, if you look at this portion of the map, what can be deduced on the values? not much I&#8217;m afraid.<br />
<a href="http://jckr.github.io/blog/wp-content/uploads/2011/02/choropleth.png"><img src="https://jckr.github.io/blog/wp-content/uploads/2011/02/choropleth.png" alt="" title="choropleth" width="123" height="132" class="aligncenter size-full wp-image-663" /></a></p>
<p>Second, it&#8217;s difficult to compare the marks on the map. Which region has the biggest? the smallest? how do two specific regions compare? with this representation, this type of question is even more difficult to answer than with a table.<br />
<a href="http://jckr.github.io/blog/wp-content/uploads/2011/02/marks-only.png"><img src="https://jckr.github.io/blog/wp-content/uploads/2011/02/marks-only.png" alt="" title="marks only" width="313" height="316" class="aligncenter size-full wp-image-664" /></a></p>
<p>Also these charts answer one partial question. So this one, here, shows which region exports most food products. But to where? and how about the imports and balance? now if one given view was the most relevant and could illustrate some important finding, it can be highlighted but here the website gives us collections of many of such maps. As a citizen I&#8217;m leaving no more informed than I was.</p>
<p>Not being the one to criticize without proposing an alternative, I whipped out an <strong>interactive exploratory tool of France trade flows</strong>.<br />
<a href="http://jckr.github.io/blog/wp-content/uploads/2011/02/franceexport.html" target=”_blank”><img src="https://jckr.github.io/blog/wp-content/uploads/2011/02/treemap.png" alt="" title="treemap" width="561" height="443" class="aligncenter size-full wp-image-668" /></a><br />
(The interactive vis is too wide to conveniently fit in a blog, but clicking on the image will open it in a new tab).</p>
<p>I don&#8217;t have access to the same dataset so I can&#8217;t show a strict equivalent. My data comes from <a href="http://comtrade.un.org/">COMTRADE</a>, the UN database of trade flows, and shows all exports and imports to France in 2009. They are not broken down by region or by type of company, but I got the flows by partner country and product category.<br />
The idea is that one can select something on one treemap to update the other. Also, it&#8217;s possible to alternate between a categorical view (where all groups of products and continents look neatly separated) and a view of the balance, which quickly shows which products or which countries get the bulk of French trade. </p>
<hr>
(technical explanation follows for those interested in the code proper)<br />
Now following last week&#8217;s <a href="http://jckr.github.io/blog/?p=426">tutorial</a>, of course it had to be done in <a href="http://www.protovis.org/">protovis</a>.<br />
Actually it illustrates some interesting principles of working with arrays, trees, maps etc. </p>
<p>First, I want to do as much data manipulation as possible in protovis as opposed to manually. So, my source <a href="http://jckr.github.io/blog/wp-content/uploads/2011/02/data.js">data</a> for the treemap is stored as an array of associative arrays, which is probably the preferred form in protovis. This is no different than, for instance, <a href="http://jckr.github.io/blog/?p=534">Protovis&#8217;s barley example</a>.<br />
Now how do you get something of the shape &#8211;</p>
<pre class="brush: jscript; title: ; notranslate">var data=
[{com:&quot;02&quot;,cat:0,cou:4,con:3,imp:0,exp:101421},
{com:&quot;03&quot;,cat:0,cou:4,con:3,imp:9716,exp:0},
{com:&quot;04&quot;,cat:0,cou:4,con:3,imp:0,exp:9272355},
{com:&quot;05&quot;,cat:0,cou:4,con:3,imp:531587,exp:0},
{com:&quot;07&quot;,cat:0,cou:4,con:3,imp:0,exp:83360},
...
{com:&quot;08&quot;,cat:0,cou:4,con:3,imp:0,exp:2779}</pre>
<p>to something shaped like a tree like:</p>
<pre class="brush: jscript; title: ; notranslate">var tree=
{0: {
       02: 101421,
       03: 0,
       04: 9272355,
       05: 0,
       07:83360},
...</pre>
<p>The solution is to use the rollup method. </p>
<p>First, if you look at my individual records, they are of the shape: </p>
<pre class="brush: jscript; light: true; title: ; notranslate">{com:&quot;04&quot;,cat:0,cou:4,con:3,imp:0,exp:9272355}</pre>
<p>where com is commodity code, cat is product category, cou is country, con is continent, imp is imports and exp is exports. </p>
<p>For any country + commodity combination, there will be <strong>only one record</strong>.<br />
What I&#8217;m interested to get in the tree I will use for the treemap are <strong>exports</strong>. That is what will determine the size of the leaves of the tree.</p>
<p>So&#8230;<br />
first I am going to nest my array:</p>
<pre class="brush: jscript; title: ; notranslate">var byProduct=pv.nest(data) 
	.key(function(d) {return d.cou;})
	.key(function(d) {return d.cat;})
	.key(function(d) {return d.com;})</pre>
<p>once I have written this I could follow up with a .entries() statement which would return me a nested array, or with rollup() which could give me the tree I need.<br />
Since, again, there is only one record for a combination of country (cou) and commodity (com), I can use any aggregation I want. </p>
<p>I define this function: </p>
<pre class="brush: jscript; title: ; notranslate">function rollup(data) {return pv.sum(data, function(d) {return d.exp;});} </pre>
<p>It returns the sum of all the export values. Since there is just one record, what it does is that it gives me the one export value I need in a tree form. </p>
<p>So the complete statement is:</p>
<pre class="brush: jscript; title: ; notranslate">function rollup(data) {return pv.sum(data, function(d) {return d.exp;});} 

var byProduct=pv.nest(data) 
	.key(function(d) {return d.cou;})
	.key(function(d) {return d.cat;})
	.key(function(d) {return d.com;})
	.rollup(rollup)</pre>
<p>This creates a tree, nested by country, then by product category, then by commodity. The corresponding values are the exports.</p>
<p>now creating my treemap data dynamically saves me a ton of hassle compared to trying to come up with a data file of the right shape and size, not mentioning the calculation errors which creep in each manual manipulation !</p>
<p>Another point of interestingness: how I computed the data to create the bar charts on the side.<br />
For the left treemap (and left bar chart) the user has selected a country. (and for the right ones, it&#8217;s a given product, but let&#8217;s focus on the left side, the reasoning is the same for the other side anyway).</p>
<p>so first I am going to take the tree we made earlier and just look at the selected country. We can do that with a statement like: </p>
<pre class="brush: jscript; title: ; notranslate">myProductTree=byProduct[selCountry];</pre>
<p>(so now we have a tree with just 2 levels, product category and commodity).</p>
<p>Now I can&#8217;t run pv.nest and all that on a tree. I need an array! so I have to use flatten to turn that section of the tree into a bona fide array which I will be able to further process. </p>
<pre class="brush: jscript; title: ; notranslate">catsByCountry = pv.flatten(myProductTree).key(&quot;cat&quot;).key(&quot;com&quot;).key(&quot;exp&quot;).array(); </pre>
<p>Here, note that the arguments: &#8220;cat&#8221;, &#8220;com&#8221;, &#8220;exp&#8221; are completely arbitrary. But, since I&#8217;m recreating the array almost as it originally was, I might as well use the same names for the keys. </p>
<p>So now, I have like a little subset of my original dataset, only the records of the selected country.<br />
I can now proceed to sum exports by categories using a standard rollup method, just as <a href="http://jckr.github.io/blog/?p=502">we&#8217;ve seen here</a>. </p>
<pre class="brush: jscript; title: ; notranslate">catsByCountry = pv.nest(catsByCountry).key(function(d) {return d.cat;}).rollup(rollup);</pre>
<p>Conveniently, the rollup function that I defined earlier sums the records! and here I do need summing, not any aggregation. </p>
<p>The problem is that the rollup() method creates an associative array, and if I need to use that in a bar chart I need a proper array! so, I use pv.values() which does just that, it creates an array out of the values of an associative array. </p>
<pre class="brush: jscript; title: ; notranslate">catsByCountry = pv.values(catsByCountry);</pre>
<p>Now the values can vary a lot in absolute terms depending on the selected country. This is why in the actual bar chart, I use pv.normalize() to have only values from 0 to 1 which are much more convenient to plot. </p>
<pre class="brush: jscript; title: ; notranslate">vis.add(pv.Bar)
	.data(function() pv.normalize(catsByCountry))</pre>
<p>one last thing, to save space in the data set (which means: bandwidth + loading time) I&#8217;ve used short keys in my data file, and I&#8217;ve used codes for countries, commodities and the like. </p>
<p>so I have this: </p>
<pre class="brush: jscript; light: true; title: ; notranslate">{com:&quot;04&quot;,cat:0,cou:4,con:3,imp:0,exp:9272355}</pre>
<p>instead of </p>
<pre class="brush: jscript; light: true; title: ; notranslate">{
    com:&quot;CEREALS,CEREAL PREPRTNS.&quot;,
    cat:&quot;Food and live animals&quot;,
    cou:&quot;Algeria&quot;,
    con:&quot;Africa&quot;,
    imp:0,exp:9272355}</pre>
<p>to get the names of the countries, categories etc. I have in my data file variables that associate, say, a country code to its long name, its continent etc.<br />
so I can have to write things like: </p>
<pre class="brush: jscript; title: ; notranslate">countries[&quot;4&quot;].name+&quot; (&quot;+continents[countries[&quot;4&quot;].continent]+&quot;)&quot;</pre>
<p>instead of something simpler, but it&#8217;s a good trade-off because writing those names in full in the original dataset inflates the size of the file to megabytes (there are approx 10.000 records).</p>
]]></content:encoded>
			<wfw:commentRss>/2011/02/18/la-france-qui-exporte/feed/</wfw:commentRss>
		<slash:comments>8</slash:comments>
		</item>
		<item>
		<title>Working with data in protovis: part 5 of 5</title>
		<link>/2011/02/11/working-with-data-in-protovis-part-5-of-5/</link>
		<comments>/2011/02/11/working-with-data-in-protovis-part-5-of-5/#comments</comments>
		<pubDate>Fri, 11 Feb 2011 18:11:22 +0000</pubDate>
		<dc:creator><![CDATA[jerome]]></dc:creator>
				<category><![CDATA[charts]]></category>
		<category><![CDATA[data visualization]]></category>
		<category><![CDATA[protovis]]></category>
		<category><![CDATA[tips]]></category>
		<category><![CDATA[arc diagrams]]></category>
		<category><![CDATA[force-directed graphs]]></category>
		<category><![CDATA[graphs]]></category>
		<category><![CDATA[layouts]]></category>
		<category><![CDATA[matrix diagrams]]></category>
		<category><![CDATA[network]]></category>
		<category><![CDATA[stacked areas]]></category>
		<category><![CDATA[stacked bars]]></category>
		<category><![CDATA[stacked columns]]></category>
		<category><![CDATA[treemaps]]></category>
		<category><![CDATA[trees]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">http://jckr.github.io/blog/?p=623</guid>
		<description><![CDATA[previous: reshaping complex arrays (4/5) Working with layouts In this final part, we&#8217;re going to look at how we can shape our data to use the protovis built-in layouts such as stacked areas, treemaps or force-directed graphs. This is not a tutorial on how to use layouts stricto sensu, and I advise anyone interested to <a class="read-more" href="/blog/2011/02/11/working-with-data-in-protovis-part-5-of-5/">&#8230;&#160;<span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>previous: <a href="http://jckr.github.io/blog/?p=502">reshaping complex arrays (4/5)</a></p>
<h2>Working with layouts</h2>
<p>In this final part, we&#8217;re going to look at how we can shape our data to use the protovis built-in layouts such as stacked areas, treemaps or force-directed graphs.<br />
This is not a tutorial on how to use layouts stricto sensu, and I advise anyone interested to first look at the <a href="http://vis.stanford.edu/protovis/docs/layout.html">protovis documentation</a> to see what can be done with this and to understand the underlying concepts. </p>
<p>But if there is one thing to know about layouts, it&#8217;s that they allow you to <strong>create non-trivial visualizations in even less code than regular protovis</strong>, provided that you <strong>pass them data in a form they can use</strong>, and this is precisely where we come in.</p>
<h3>Three great categories of layouts</h3>
<p>Currently, there are no fewer than 13 types of layouts in Protovis. Fortunately, there are examples for all of them in the gallery.<br />
There are layouts for: </p>
<ul>
<li>Arrays of data</li>
<ul>
<li>
Grids or heatmaps <a href="http://vis.stanford.edu/protovis/jsdoc/symbols/pv.Layout.Grid.html">doc</a> <a href="http://vis.stanford.edu/protovis/ex/heatmap.html">example</a>
</li>
<li>
Stacked areas or streamgraphs <a href="http://vis.stanford.edu/protovis/jsdoc/symbols/pv.Layout.Stack.html">doc</a> <a href="http://vis.stanford.edu/protovis/ex/stack.html">stacked areas</a> <a href="http://vis.stanford.edu/protovis/ex/stream.html">streamgraphs</a>
</li>
</ul>
<li>Networks (nodes and links)</td>
<td>Hierarchized data (trees)</li>
<ul>
<li>
Arc diagrams <a href="http://vis.stanford.edu/protovis/jsdoc/symbols/pv.Layout.Arc.html">doc</a> <a href="http://vis.stanford.edu/protovis/ex/arc.html">example</a></li>
<li>
Force-directed graphs <a href="http://vis.stanford.edu/protovis/jsdoc/symbols/pv.Layout.Force.html">doc</a> <a href="http://vis.stanford.edu/protovis/ex/force.html">example </a>
</li>
<li>
Relationship matrices <a href="http://vis.stanford.edu/protovis/jsdoc/symbols/pv.Layout.Matrix.html">doc</a> <a href="http://vis.stanford.edu/protovis/ex/matrix.html">example</a>
</li>
<li>Rollup network<a href="http://vis.stanford.edu/protovis/jsdoc/symbols/pv.Layout.Rollup.html">doc</a> (no example in Protovis 3.2, but there is one in 3.3)</li>
</ul>
<li>Trees and hierarchized data</li>
<ul>
<li>
Dendograms <a href="http://vis.stanford.edu/protovis/jsdoc/symbols/pv.Layout.Cluster.html">doc </a><a href="http://vis.stanford.edu/protovis/ex/dendrogram.html">example</a>
</li>
<li>
Indented trees <a href="http://vis.stanford.edu/protovis/jsdoc/symbols/pv.Layout.Indent.html">doc</a> <a href="http://vis.stanford.edu/protovis/ex/indent.html">example</a>
</li>
<li>
Packed circles <a href="http://vis.stanford.edu/protovis/jsdoc/symbols/pv.Layout.Pack.html">doc</a> <a href="http://vis.stanford.edu/protovis/ex/pack.html">example</a>
</li>
<li>
Sunbursts and icicles <a href="http://vis.stanford.edu/protovis/jsdoc/symbols/pv.Layout.Partition.html">doc</a> <a href="http://vis.stanford.edu/protovis/ex/sunburst.html">sunbursts</a> <a href="http://vis.stanford.edu/protovis/ex/icicle.html">icicles</a>
</li>
<li>
Node-link trees <a href="http://vis.stanford.edu/protovis/jsdoc/symbols/pv.Layout.Tree.html">doc</a> <a href="http://vis.stanford.edu/protovis/ex/tree.html">example</a></li>
<li>Treemaps <a href="http://vis.stanford.edu/protovis/jsdoc/symbols/pv.Layout.Treemap.html">doc</a> <a href="http://vis.stanford.edu/protovis/ex/treemap.html">example</a></li>
</ul>
</ul>
<p>In addition, there are layouts like <a href="http://vis.stanford.edu/protovis/jsdoc/symbols/pv.Layout.Bullet.html">pv.Layout.Bullet</a> which require data to have a certain specific shape but the <a href="http://vis.stanford.edu/protovis/ex/bullet.html">example from the gallery</a> is very explicit. (et tu, <a href="http://vis.stanford.edu/protovis/ex/horizon.html">Horizon</a> layout).</p>
<h3>Arrays of data</h3>
<p>In order to work with this kind of layout, the simplest thing is to put your data in a 2-dimensional array: </p>
<pre class="brush: jscript; title: ; notranslate">var data=[
   [8,3,7,2,5],
   [9,6,1,7,4],
    ...
   [7,4,3,6,8]
];</pre>
<p>For the grid layout, this gives you an array of cells divided in columns (number of elements in each line) and rows (number of lines).<br />
The idea of the grid layout is that your cells are automatically positioned and sized, so afaik the only thing you can do is add a mark such as a pv.Bar which would fill them completely, but which you could still style with fillStyle or strokeStyle. You can&#8217;t really access the underlying data with functions but you can use methods that rely on default values, like adding labels.</p>
<p>For instance, you can use it to generate a QR code: </p>
<table>
<tr>
<td>
<pre class="brush: jscript; title: ; notranslate">var qr=[
&quot;000000000000000000000000000&quot;,
&quot;011111110001010100011111110&quot;,
&quot;010000010101001110010000010&quot;,
&quot;010111010000010100010111010&quot;,
&quot;010111010111011110010111010&quot;,
&quot;010111010010000001010111010&quot;,
&quot;010000010110110010010000010&quot;,
&quot;011111110101010101011111110&quot;,
&quot;000000000011100100000000000&quot;,
&quot;011111011110101110101010100&quot;,
&quot;000010101001010111101000100&quot;,
&quot;010101111001001011111010110&quot;,
&quot;001011000100010101010100010&quot;,
&quot;001100010111011010010101110&quot;,
&quot;010101100110001101001010100&quot;,
&quot;010011010011111111100110110&quot;,
&quot;010111101010100101000010010&quot;,
&quot;010100110010111101111101000&quot;,
&quot;000000000101010111000111000&quot;,
&quot;011111110100011001010111110&quot;,
&quot;010000010000110011000110110&quot;,
&quot;010111010110001011111111000&quot;,
&quot;010111010101101100110101110&quot;,
&quot;010111010100000111001001010&quot;,
&quot;010000010111010101101110010&quot;,
&quot;011111110101001100011111110&quot;,
&quot;000000000000000000000000000&quot;,
].map(function(i) i.split(&quot;&quot;));

var vis = new pv.Panel()
    .width(216)
    .height(216);
vis.add(pv.Layout.Grid)
    .rows(qr)
 	.cell.add(pv.Bar)
 	    .fillStyle(pv.colors(&quot;#fff&quot;, &quot;#000&quot;))
     ;
vis.render();</pre>
</td>
<td><a href="http://jckr.github.io/blog/wp-content/uploads/2011/02/QR-grid-big.png"><img src="https://jckr.github.io/blog/wp-content/uploads/2011/02/QR-grid-big.png" alt="" title="QR-grid-big" width="216" height="216" class="aligncenter size-full wp-image-628" /></a>(BTW, this is the QR code to this page)</td>
</tr>
</table>
<p>On line 29, I&#8217;m using a <a href="http://jckr.github.io/blog/?p=494">map function</a> to turn this array of strings, which is easier and shorter to type, into a <em>bona fide</em> 2-dimensional array. </p>
<p>That&#8217;s all there is to grids, of all the layouts they are among the easiest to reproduce with regular protovis.</p>
<p>Now, stacks.<br />
The easiest way to use them is to pass them 2-dimensional arrays. Now it doesn&#8217;t have to be arrays of numbers, it can be arrays of associative arrays in case you need to do something exotic. But for the following examples let&#8217;s just assume you don&#8217;t. Here is how you&#8217;d do a stacked area, stacked columns and stacked bars respectively:</p>
<table>
<tr>
<td>
<pre class="brush: jscript; title: ; notranslate">var data=[
[[1000,1200,1500,1700]]
[[100,500,300,200]]
]
var vis=new pv.Panel().width(200).height(200);
vis.add(pv.Layout.Stack)
    .layers(data)
    .x(function() 50*this.index)
    .y(function(d) d/20)
    .layer.add(pv.Area)</pre>
</td>
<td><a href="http://jckr.github.io/blog/wp-content/uploads/2011/02/stackedAreas.png"><img src="https://jckr.github.io/blog/wp-content/uploads/2011/02/stackedAreas.png" alt="" title="stackedAreas" width="200" height="200" class="aligncenter size-full wp-image-636" /></a></td>
</tr>
</table>
<p>all you need is to feed the layers, x, y properties of your stack, then say what you want to add to your layers.<br />
Now, columns: </p>
<table>
<tr>
<td>
<pre class="brush: jscript; first-line: 6; title: ; notranslate">vis.add(pv.Layout.Stack)
    .layers(data)
    .x(function() 50*this.index)
    .y(function(d) d/20)
    .layer.add(pv.Bar).width(40)</pre>
</td>
<td><a href="http://jckr.github.io/blog/wp-content/uploads/2011/02/stackedColumns.png"><img src="https://jckr.github.io/blog/wp-content/uploads/2011/02/stackedColumns.png" alt="" title="stackedColumns" width="200" height="200" class="aligncenter size-full wp-image-637" /></a></td>
</tr>
</table>
<p>and finally, bars: </p>
<table>
<tr>
<td>
<pre class="brush: jscript; first-line: 6; highlight: [8,11]; title: ; notranslate">vis.add(pv.Layout.Stack)
    .layers(data)
    .orient(&quot;left&quot;)
    .x(function() 50*this.index)
    .y(function(d) d/20)
    .layer.add(pv.Bar).height(40)</pre>
</td>
<td><a href="http://jckr.github.io/blog/wp-content/uploads/2011/02/stackedBars.png"><img src="https://jckr.github.io/blog/wp-content/uploads/2011/02/stackedBars.png" alt="" title="stackedBars" width="200" height="200" class="aligncenter size-full wp-image-638" /></a></td>
</tr>
</table>
<p>For bars, there is a little trick here. I specify that the layer orientation is horizontal (&#8220;left&#8221;) and I change the height instead of the width of the added pv.Bar.<br />
And that all there is. You can create various streamgraphs by <a href="http://vis.stanford.edu/protovis/jsdoc/symbols/pv.Layout.Stack.html#offset">playing with the order and offset properties</a> of the stack but this doesn&#8217;t change anything to the data structure, so we&#8217;re done here.</p>
<h3>Representing networks</h3>
<p>Protovis provides 3 cool layouts to easily exhibit relationships between nodes: arc diagrams, matrix diagrams and force-directed layouts.<br />
The good news is that the shape of the data required by those three layouts is identical. </p>
<p>They require an array that correponds to the nodes. This can be as simple as a pv.range(), or as sophisticated as an array of associative arrays if you want to style your network graph according to several potential attributes of the node. </p>
<p>And they also require an array for the links. This array has a more rigid form, it must be an array of associative arrays of the shape: {source: #, target: #, value: #} where the values for source and target correspond to the position of a node in the node array, and value indicates the strength of the link. </p>
<p>So let&#8217;s do a simple one. </p>
<table>
<tr>
<td>
<pre class="brush: jscript; title: ; notranslate">var nodes=pv.range(6); // why more complex, right?
var links=[
{source:0, target:1, value:2},
{source:1, target:2, value:1},
{source:1, target:3, value:1},
{source:2, target:4, value:4},
{source:3, target:5, value:1},
{source:4, target:5, value:1},
{source:1, target:5, value:3}
]
var vis = new pv.Panel()
    .width(200)
    .height(200)
    ;
var arc = vis.add(pv.Layout.Arc)
    .nodes(nodes)
    .links(links)
	.bottom(100)
arc.link.add(pv.Line);
arc.node.add(pv.Dot)
    .size(50)
vis.render();</pre>
</td>
<td><a href="http://jckr.github.io/blog/wp-content/uploads/2011/02/simpleNetwork1.png"><img src="https://jckr.github.io/blog/wp-content/uploads/2011/02/simpleNetwork1.png" alt="" title="simpleNetwork" width="200" height="200" class="aligncenter size-full wp-image-644" /></a></td>
</tr>
</table>
<p>Here, by varying the strength of the link, the thickness of the arcs changes accordingly. The nodes are left unstyled, had we passed a more complicated dataset to the nodes array, we could have changed their properties (fillStyle, size, strokeStyle, labels etc.) with appropriate accessor functions. </p>
<p>With little modifications we can create a force-directed layout and a matrix diagram.</p>
<table>
<tr>
<td>
<pre class="brush: jscript; first-line: 14; title: ; notranslate">
var force = vis.add(pv.Layout.Force)
    .nodes(nodes)
    .links(links);

force.link.add(pv.Line);

force.node.add(pv.Dot)
	.size(50)
	.anchor(&quot;center&quot;).add(pv.Label)
		.text(function() this.index);

vis.render();
</pre>
</td>
<td><a href="http://jckr.github.io/blog/wp-content/uploads/2011/02/simpleForce.png"><img src="https://jckr.github.io/blog/wp-content/uploads/2011/02/simpleForce.png" alt="" title="simpleForce" width="200" height="200" class="aligncenter size-full wp-image-645" /></a></td>
</tr>
</table>
<p>Here I labelled the nodes so one can tell which is which. This is done by adding a pv.Label to the pv.Dot that&#8217;s attached to the node, just like with any other mark.</p>
<table>
<tr>
<td>
<pre class="brush: jscript; first-line: 14; title: ; notranslate">
var Matrix = vis.add(pv.Layout.Matrix)
	.nodes(nodes)
	.directed(true)
	.links(links)
	.top(20).left(20)

Matrix.link.add(pv.Bar)
    .fillStyle(function(d) pv.Scale.linear(0, 2, 4)
      .range('#eee', 'yellow', 'green')(d.linkValue))

Matrix.label.add(pv.Label).text(function() Math.floor(this.index/2))

vis.render();</pre>
</td>
<td><a href="http://jckr.github.io/blog/wp-content/uploads/2011/02/simpleMatrix1.png"><img src="https://jckr.github.io/blog/wp-content/uploads/2011/02/simpleMatrix1.png" alt="" title="simpleMatrix" width="200" height="200" class="aligncenter size-full wp-image-647" /></a></td>
</tr>
</table>
<p>For the matrix things are slightly more complex than for the previous 2. Here I opted for a directed matrix, as opposed to a bidirectional one: this means that each link is shown once, to its source from its target, and not twice (ie from its target back to its source) which is the default.<br />
I chose to color the bar attached to my links (which are cells of the matrix) according to the strength of my links. Again, if my nodes field was more qualified, I could have used these properties. </p>
<p>Finally, we&#8217;ve added labels to the custom property Matrix.label. Only, the labels are numbered from 0 to 11 so to get numbers from 0 to 5 for both rows and columns I used Math.floor(this.index/2) (integer part of half of this number).</p>
<h3>Hierarchized data</h3>
<p>Like for networks, the shape of the data we can feed to treemaps, icicles and other hierarchical representation doesn&#8217;t change. So once you have your data in order, you can easily switch representations. </p>
<p>Essentially, you will be passing a tree of the form: </p>
<pre class="brush: jscript; title: ; notranslate">var myTree={
   rootnode: {
      node: {
      ...  
         node: {
            leaf: value,
            leaf: value,
            ...
            leaf: value
         },
      ...  
}</pre>
<p>The protovis examples use the hierarchy of <a href="http://vis.stanford.edu/protovis/ex/flare.js">flare source code</a> as an example, which really shows what can be done with a treemap and other tree represenations. </p>
<p>For our purpose we are going for a simpler tree, inspired by the work of Periscopic on <a href="http://www.congressspeaks.com/">congressspeaks.com</a> which Kim Rees showed at <a href="http://now.periscopic.com/2011/02/lessons-in-visual-economy-at-strata/">Strata</a>.<br />
Kim presentation featured tiny treemaps that showed the voting record for a congressperson, and whether they had voted for or against their party.</p>
<p>So let&#8217;s play with the voting record of an hypothetic congressperson:</p>
<pre class="brush: jscript; title: ; notranslate">var hasVoted={
	didnt: 100,
	voted: {
	    yes: {
	        yesWithParty: 241,
	        yesAgainstParty: 23
	    },
	    no: {
	        noWithParty: 73,
	        noAgainstParty: 5
	    }
	}
};</pre>
<p>Once you have your tree, you will need to pass it to your layout using pv.dom, like this: </p>
<pre class="brush: jscript; light: true; title: ; notranslate">pv.dom(hasVoted).root(&quot;hasVoted&quot;).nodes()</pre>
<p>Based on that let&#8217;s do two hierarchical representations.<br />
Let&#8217;s start with a tree: </p>
<pre class="brush: jscript; first-line: 14; title: ; notranslate">var vis = new pv.Panel()
    .width(500)
    .height(200)
    ;
var tree = vis.add(pv.Layout.Tree)
    .nodes(pv.dom(hasVoted).root(&quot;hasVoted&quot;).nodes())
    .depth(40)
    .breadth(100)
    .top(30)
    .right(100)
    ;
tree.link.add(pv.Line);
tree.node.add(pv.Dot)
    .size(function(n) n.nodeValue)
	.anchor(&quot;center&quot;).add(pv.Label).textAlign(&quot;center&quot;).text(function(n) n.nodeName)
vis.render();</pre>
<p>And here is the result:<br />
<a href="http://jckr.github.io/blog/wp-content/uploads/2011/02/simpleTree.png"><img src="https://jckr.github.io/blog/wp-content/uploads/2011/02/simpleTree.png" alt="" title="simpleTree" width="500" height="200" class="aligncenter size-full wp-image-652" /></a></p>
<p>There are many styling possibilities obviously left unexplored in this simple example (you can control properties of the tree.link, tree.node, tree.labels which we didn&#8217;t use here, etc.), but this won&#8217;t change much as far as data are concerned. </p>
<p>Now let&#8217;s try a treemap with the same dataset.</p>
<pre class="brush: jscript; first-line: 14; title: ; notranslate">var vis = new pv.Panel()
    .width(400)
    .height(200)
    ;

var tree = vis.add(pv.Layout.Treemap)
	.width(200).height(200)
    .nodes(pv.dom(hasVoted).root(&quot;hasVoted&quot;).nodes())
    ;

tree.leaf.add(pv.Panel)
	.fillStyle(function(d) d.nodeName==&quot;didnt&quot;?&quot;darkgrey&quot;:d.nodeName.slice(0,3)==&quot;yes&quot;?
	d.nodeName.slice(-9)==&quot;WithParty&quot;?&quot;powderblue&quot;:&quot;steelblue&quot;:
	d.nodeName.slice(-9)==&quot;WithParty&quot;?&quot;lightsalmon&quot;:&quot;salmon&quot;)

vis.add(pv.Panel)
	.data([
		   {label:&quot;yes with party&quot;, 	color: &quot;powderblue&quot;},
		   {label:&quot;yes against party&quot;, 	color: &quot;steelblue&quot;},
		   {label:&quot;no with party&quot;, 		color: &quot;lightsalmon&quot;},
		   {label:&quot;no against party&quot;, 	color: &quot;salmon&quot;},
		   {label:&quot;didn't vote&quot;, 		color: &quot;darkgrey&quot;}
		   ])
	.left(220)
	.top(function() 50+20*this.index)
	.height(15)
	.width(20)
	.fillStyle(function(d) d.color)
	.anchor(&quot;right&quot;).add(pv.Label).textAlign(&quot;left&quot;).text(function(d) d.label)

vis.render();
</pre>
<p>and what took the longest part of the code was making the legend.</p>
<p>Here is the outcome:<br />
<a href="http://jckr.github.io/blog/wp-content/uploads/2011/02/simpleTreemap.png"><img src="https://jckr.github.io/blog/wp-content/uploads/2011/02/simpleTreemap.png" alt="" title="simpleTreemap" width="400" height="200" class="aligncenter size-full wp-image-653" /></a></p>
]]></content:encoded>
			<wfw:commentRss>/2011/02/11/working-with-data-in-protovis-part-5-of-5/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
	</channel>
</rss>
