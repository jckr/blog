<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>arrays &#8211; jckr.github.io/blog</title>
	<atom:link href="http://localhost/tag/arrays/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>Just another WordPress site</description>
	<lastBuildDate>Wed, 17 Aug 2016 05:36:39 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.10</generator>
	<item>
		<title>Protovis: analysis of the Map projections example</title>
		<link>/2011/03/15/protovis-analysis-of-the-map-projections-example/</link>
		<comments>/2011/03/15/protovis-analysis-of-the-map-projections-example/#respond</comments>
		<pubDate>Tue, 15 Mar 2011 16:17:31 +0000</pubDate>
		<dc:creator><![CDATA[jerome]]></dc:creator>
				<category><![CDATA[data visualization]]></category>
		<category><![CDATA[protovis]]></category>
		<category><![CDATA[arrays]]></category>
		<category><![CDATA[data]]></category>
		<category><![CDATA[map]]></category>
		<category><![CDATA[projections]]></category>

		<guid isPermaLink="false">http://jckr.github.io/blog/?p=573</guid>
		<description><![CDATA[What is a map? before we start looking at the code it may be a good idea to think of the best way to represent a country. Countries are areas of land surrounded by borders, which are imaginary (or sometimes physical) lines going through a set of points. Some countries are made of one of <a class="read-more" href="/blog/2011/03/15/protovis-analysis-of-the-map-projections-example/">&#8230;&#160;<span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<h2>What is a map?</h2>
<p>before we start looking at the code it may be a good idea to think of the best way to represent a country.<br />
Countries are areas of land surrounded by borders, which are imaginary (or sometimes physical) <strong>lines</strong> going through a set of <strong>points</strong>.<br />
<a href="http://jckr.github.io/blog/wp-content/uploads/2011/03/square.png"><img src="https://jckr.github.io/blog/wp-content/uploads/2011/03/square.png" alt="" title="square" width="200" height="200" class="aligncenter size-full wp-image-748" /></a></p>
<p>Some countries are made of one of such surfaces, but many countries are not one contiguous territory (they may include islands for instance) so they could be made out of <strong>several disjointed polygons</strong>.<br />
<a href="http://jckr.github.io/blog/wp-content/uploads/2011/03/square1.png"><img src="https://jckr.github.io/blog/wp-content/uploads/2011/03/square1.png" alt="" title="square" width="200" height="200" class="aligncenter size-full wp-image-749" /></a>.</p>
<p>Now let&#8217;s put on our protovis hat. Let&#8217;s suppose we want to draw a map where each country could be colored differently (choropleth). What kind of data structure should be use to represent that?<br />
First there should be a sort of array of countries. Each country should be an item in that array, so they can be indexed and assigned an individual color and various data points.<br />
Then, at the lowest level, we would be drawing polygons, which are treated as pv.Line in protovis. For each polygon, we would require an array of coordinate pairs. To draw a country, we would need a list (array) of those polygons. </p>
<p>So the data structure we are looking at is: </p>
<pre class="brush: jscript; title: ; notranslate">var world=[  // an array of countries
    [ // an array of polygons
        [ // an array of pairs of coordinates
            [x0, y0], // coordinates of the first point
            [x1, y1], // coordinates of the next one
                ... 
            [xn, yn],
            [x0, y0]  // coordinates of the first point to close the polygon
        ]
       ...              // another polygon, but maybe not.
   ], 
   [                    // next country
  ...
   ]
...
]</pre>
<h2>the map projections example</h2>
<p><a href="http://jckr.github.io/blog/wp-content/uploads/2011/03/projections.png"><img src="https://jckr.github.io/blog/wp-content/uploads/2011/03/projections.png" alt="" title="projections" width="600" height="360" class="aligncenter size-full wp-image-754" /></a></p>
<p>Can be found <a href="http://vis.stanford.edu/protovis/ex/projection.html">here: </a> http://vis.stanford.edu/protovis/ex/projection.html</p>
<pre class="brush: jscript; title: ; notranslate">/*
 * A diverging color scale, using previously-computed quantiles of population
 * densities; in the future, we might use a quantile scale here to do this
 * automatically. Map colors based on www.ColorBrewer.org, by Cynthia A. Brewer,
 * Penn State.
 */
var fill = pv.Scale.linear()
    .domain(140, 650, 1900)
    .range(&quot;#91bfdb&quot;, &quot;#ffffbf&quot;, &quot;#fc8d59&quot;);

/* Precompute the country's population density and color. */
countries.forEach(function(c) {
  c.color = stats[c.code].area
      ? fill(stats[c.code].pop / stats[c.code].area)
      : &quot;#ccc&quot;; // unknown
});

var w = 860,
    h = 3 / 5 * w,
    geo = pv.Geo.scale(&quot;hammer&quot;).range(w, h);

var vis = new pv.Panel()
    .width(w)
    .height(h);

/* Countries. */
vis.add(pv.Panel)
    .data(countries)
  .add(pv.Panel)
    .data(function(c) c.borders)
  .add(pv.Line)
    .data(function(b) b)
    .left(geo.x)
    .top(geo.y)
    .title(function(d, b, c) c.name)
    .fillStyle(function(d, b, c) c.color)
    .strokeStyle(function() this.fillStyle().darker())
    .lineWidth(1)
    .antialias(false);

/* Latitude ticks. */
vis.add(pv.Panel)
    .data(geo.ticks.lat())
  .add(pv.Line)
    .data(function(b) b)
    .left(geo.x)
    .top(geo.y)
    .strokeStyle(&quot;rgba(128,128,128,.3)&quot;)
    .lineWidth(1)
    .interpolate(&quot;cardinal&quot;)
    .antialias(false);

/* Longitude ticks. */
vis.add(pv.Panel)
    .data(geo.ticks.lng())
  .add(pv.Line)
    .data(function(b) b)
    .left(geo.x)
    .top(geo.y)
    .strokeStyle(&quot;rgba(128,128,128,.3)&quot;)
    .lineWidth(1)
    .interpolate(&quot;cardinal&quot;)
    .antialias(false);

vis.render();
</pre>
<p>In addition there are two arrays of the following shape:<br />
First, stats which is an associative arrays of associative arrays, and which associate each 2-letter country code with values of population and area:</p>
<pre class="brush: jscript; light: true; title: ; notranslate">
var stats = {
'AG': {pop:83039, area:44},
'DZ': {pop:32854159, area:238174},
...
'US': {pop:299846449, area:915896},
...
};
</pre>
<p>Then, countries, which is an array of associative arrays.</p>
<pre class="brush: jscript; light: true; title: ; notranslate">
var countries = [
{code:'AG', name:&quot;Antigua and Barbuda&quot;, 
borders:[ // an array of one or several areas, 
  [ // an array of coordinates, 
    [ // a pair of the form longitude, lattitude
       ...
    ]
  ]
]}
...
]</pre>
<p>Now this second data structure looks a lot like the one we&#8217;ve drafted in the prologue. All the geographic information is tucked in a property called &#8220;borders&#8221;. The array has other properties for comfort.<br />
Because the data is put in the right shape and order, this script can produce a very good map with a remarkable economy of code.<br />
This example has been put together to showcase the various map projections of protovis (identity, mercator, and so on.). These projections have zero impact on the way data should be assembled for making maps, so we&#8217;ll just treat them as &#8220;magic&#8221;. </p>
<pre class="brush: jscript; title: ; notranslate">/*
 * A diverging color scale, using previously-computed quantiles of population
 * densities; in the future, we might use a quantile scale here to do this
 * automatically. Map colors based on www.ColorBrewer.org, by Cynthia A. Brewer,
 * Penn State.
 */
var fill = pv.Scale.linear()
    .domain(140, 650, 1900)
    .range(&quot;#91bfdb&quot;, &quot;#ffffbf&quot;, &quot;#fc8d59&quot;);
</pre>
<p>This part creates a color scale which will return a color according to the value passed to it. The color returned will be somewhere between the ones specified in the range, depending on where the value is relatively to the values specified in the domain. So a value of 140 will result in a color of #91bfdb (bluish), it will go towards the grey as the value moves up to 650, and towards #fc8d59 (redish) as the value goes up to 1900.</p>
<pre class="brush: jscript; first-line: 11; title: ; notranslate">/* Precompute the country's population density and color. */
countries.forEach(function(c) {
  c.color = stats[c.code].area
      ? fill(stats[c.code].pop / stats[c.code].area)
      : &quot;#ccc&quot;; // unknown
});</pre>
<p>As the remark says, this will precompute the country&#8217;s color once and for all.<br />
The <a href="http://jckr.github.io/blog/?p=494">forEach() method</a> goes to every element of the countries array.<br />
the c.color = statement will add a color key to each element of that array (which, as you may recall, already has values for the code, name and borders keys.<br />
What it does is that is retrieves the country code of that element of countries, c.code, and uses that to find out whether we have an area value for that country code (this is stats[/c].area?).<br />
If this is the case, we are going to compute the color that should be attributed to the country, by passing the population divided by the area to the color scale we just made. Else, we just use light grey.</p>
<p>The next few lines are standard constants that will shape the vis.<br />
Note however </p>
<pre class="brush: jscript; first-line: 20; title: ; notranslate">geo = pv.Geo.scale(&quot;hammer&quot;).range(w, h)</pre>
<p>This is a geographic scale, which will be used to convert longitudes and latitudes to X and Y coordinates on the screen.</p>
<pre class="brush: jscript; first-line: 26; title: ; notranslate">/* Countries. */
vis.add(pv.Panel)
    .data(countries)
  .add(pv.Panel)
    .data(function(c) c.borders)
  .add(pv.Line)
    .data(function(b) b)
    .left(geo.x)
    .top(geo.y)
    .title(function(d, b, c) c.name)
    .fillStyle(function(d, b, c) c.color)
    .strokeStyle(function() this.fillStyle().darker())
    .lineWidth(1)
    .antialias(false);</pre>
<p>This is where it all happens.<br />
First, we create a series of panels, one for each country. So, we pass the countries array as data.<br />
Then, we are going to create another series of panels for every country, that is, with as many panels as there are independent areas in the country. For instance, if there are islands, we are going to need extra panels to represent them. If the country is one contiguous mass of land, there will be just one panel here.<br />
This time, we use function(c) c.borders as data. That is, we go into the borders array.</p>
<p>Finally, we are going to create a filled polygon for each of these independent areas. This is achieved by adding a pv.Line to the previous panels. Likewise, we use (function(b) b) as data, meaning that we go yet another level into the borders array. Now, we are accessing the pairs of longitude + latitude numbers.</p>
<p>geo.x and geo.y convert this pair of numbers to X and Y coordinates on the screen.<br />
For the next two lines, title and fillStyle, we need to go back to the country level.<br />
so, we use a function of the form <a href="http://jckr.github.io/blog/?p=479">function(d,b,c)</a>. d is the current item (pair of longitude, latitude), b its parent (individual area) and c, its grand-parent (the country).<br />
so, function(d,b,c) c.name retrieves the country name, and function(d,b,c) c.color retrieves the color we had computed for that country to begin with.</p>
<p>For the color of the border, we wish to use a darker version of the fill color. This is what the this.fillStyle().darker() does.</p>
<p>The rest of the vis is longitude and latitude ticks, using the built-in properties of the scale.</p>
]]></content:encoded>
			<wfw:commentRss>/2011/03/15/protovis-analysis-of-the-map-projections-example/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Working with data in protovis – part 3 of 5</title>
		<link>/2011/02/09/working-with-data-in-protovis-part-3-of-5/</link>
		<comments>/2011/02/09/working-with-data-in-protovis-part-3-of-5/#comments</comments>
		<pubDate>Wed, 09 Feb 2011 17:08:57 +0000</pubDate>
		<dc:creator><![CDATA[jerome]]></dc:creator>
				<category><![CDATA[charts]]></category>
		<category><![CDATA[data visualization]]></category>
		<category><![CDATA[protovis]]></category>
		<category><![CDATA[tips]]></category>
		<category><![CDATA[arrays]]></category>
		<category><![CDATA[javascript]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">http://jckr.github.io/blog/?p=494</guid>
		<description><![CDATA[Previous : Multi-dimensional arrays, inheritance and hierarchy Short interlude: what can be done with arrays in javascript? Now that we have a grasp on how arrays work and how they can be used in protovis, let’s take a step back and look at some very useful methods for working with arrays in standard javascript. Sorting <a class="read-more" href="/blog/2011/02/09/working-with-data-in-protovis-part-3-of-5/">&#8230;&#160;<span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>Previous : <a href="http://jckr.github.io/blog/?p=479">Multi-dimensional arrays, inheritance and hierarchy</a></p>
<h2>Short interlude: what can be done with arrays in javascript?</h2>
<p>Now that we have a grasp on how arrays work and how they can be used in protovis, let’s take a step back and look at some very useful methods for working with arrays in standard javascript.</p>
<h3>Sorting arrays</h3>
<p>Using a method called, well, sort(), javascript arrays can be reordered in a variety of ways.</p>
<pre class="brush: jscript; title: ; notranslate">var a = [1, 1.2, 1.7, 1.5, .7, .3];
a.sort();</pre>
<p>Without any argument, this will sort the array in ascending order: [0.3, 0.7, 1, 1.2, 1.5, 1.7].</p>
<p>However, we can reorder the array differently with a comparison function, such as:</p>
<pre class="brush: jscript; title: ; notranslate">a.sort(function(a,b) b-a)</pre>
<p>Note that this is protovis notation. In traditional javascript, you’d have written a.sort(function(a,b) {return b-a;});</p>
<p>This would sort a in descending order ([1.7, 1.5, 1.2, 1, 0.7, 0.3]). Here is how it works.</p>
<p>The comparison function takes 2 elements in the array. If the first element (corresponding to the first argument, a) should appear first, the function must return a negative number. If the result is positive, the second element is appearing first. With our example, b-a is negative when the first element is greater than the second. So, this function sorts an array in descending order.</p>
<p>Sort also works with arrays of associative arrays. For instance:</p>
<pre class="brush: jscript; title: ; notranslate">var data = [
  {key:&quot;a&quot;, value:1},
  {key:&quot;b&quot;, value:1.2},
  {key:&quot;c&quot;, value:1.7}, 
  {key:&quot;d&quot;, value:1.5},
  {key:&quot;e&quot;, value:.7},
  {key:&quot;f&quot;, value:.3}
];

data.sort(function(a,b) b.value-a.value);
</pre>
<p>Here, we have to specify which criterion is used to sort the array. In this example, we sort it in descending order by value. But we could have sorted it in ascending order by key, for instance.</p>
<p>The method reverse() turns an array upside down.</p>
<pre class="brush: jscript; title: ; notranslate">
var a = [1, 1.2, 1.7, 1.5, .7, .3];

a.reverse(); // gives [0.3, 0.7, 1.5, 1.7, 1.2, 1]
</pre>
<p>So, a.sort().reverse() will also sort that array in decreasing order.</p>
<h3>Extracting sub-arrays</h3>
<p>The method slice() will extract a sub-array out of an array, in other words, it will retrieve certain elements. It works with one or two arguments. If you only give one argument, it will give you the last elements from the index you specified.</p>
<p>For instance,</p>
<pre class="brush: jscript; title: ; notranslate">[1, 1.2, 1.7, 1.5, .7, .3].slice(3) // it's [1.5, 0.7, 0.3]</pre>
<p>The index 3 corresponds to the 4<sup>th</sup> element of the array (0,1,2,3) so slice(3) will return the 4<sup>th</sup>, 5<sup>th</sup> and 6<sup>th</sup> elements.</p>
<p>With 2 arguments, you get a sub-array that starts at the first index but ends just before the 2<sup>nd</sup> one. For instance,</p>
<pre class="brush: jscript; title: ; notranslate">[1, 1.2, 1.7, 1.5, .7, .3].slice(0,3) // gives [1, 1.2, 1.7]</pre>
<p>It is also possible to use negative arguments. Instead of counting from the beginning of the array, it means counting from the end.</p>
<pre class="brush: jscript; title: ; notranslate">[1, 1.2, 1.7, 1.5, .7, .3].slice(-1) // result: [0.3]</pre>
<h3>Turning a string into an array</h3>
<p>This can be done via the split() method.</p>
<p>split() normally works with a separator, for instance &#8220;07/04/1975&#8221;.split(&#8220;/&#8221;) is [&#8220;07&#8221;, &#8220;04&#8221;, &#8220;1975&#8221;], but if an empty string is used, then each character becomes an element of the new array. For instance,</p>
<pre class="brush: jscript; title: ; notranslate">&quot;ABCDEFGHIJ&quot;.split(&quot;&quot;) // result: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;] </pre>
<p>This can be very useful to generate data on the go.</p>
<h2>And what methods does protovis has for working with arrays and data?</h2>
<p>Many.</p>
<p>Some simple, some very elaborate. In addition to visualization functions protovis has impressive data processing capabilities.</p>
<h3>The workhorse: pv.range()</h3>
<p>pv.range() is a method that creates an array of numbers.</p>
<p>pv.range(10), for instance, is [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], or the 10 first integers starting from 0.<br />
(this is the method I referred to in the example of the previous part).</p>
<p>By using the other arguments, it is possible to generate arrays of numbers that go from one specific index to another, or to change the step. For instance:</p>
<pre class="brush: jscript; title: ; notranslate">pv.range(5,10) // is [5, 6, 7, 8, 9]
pv.range(5,21,5) // is [5, 10, 15, 20]</pre>
<p>While this may not look incredible at first sight, pv.range() really shines when associated with other functions or methods such as map().</p>
<p>map()  is an array method that creates a new array by applying a function to each of the element of the array it’s run against. For instance,</p>
<pre class="brush: jscript; title: ; notranslate">var data = pv.range(100).map(Math.random) // creates an array of 100 random numbers.

var data = pv.range(1000).map(function(a) Math.cos(a/1000)) // stores into data 1000 values 
// of cos(x) for all the numbers between 0 and 0.999 by increment of 0.001.</pre>
<p>In other words, pv.range() and map() can quickly create very interesting datasets for protovis to visualize.</p>
<h3>Simple statistical functions that make life easier</h3>
<h4>pv.min(), pv.max()</h4>
<p>Protovis has functions that extract the maximum or the minimum value of an array.</p>
<p>pv.min([1, 1.2, 1.7, 1.5, .7, .3]) will return the value of the smallest element of the array, in that case 0.3.</p>
<p>Likewise, pv.max returns the value of the greatest element of the array.</p>
<p>Both of these can be used with an accessor function to help retrieve what will be compared.</p>
<p>For instance:</p>
<pre class="brush: jscript; title: ; notranslate">
var data = [
  {key:&quot;a&quot;, value:1},
  {key:&quot;b&quot;,value:1.2},
  {key:&quot;c&quot;, value:1.7}, 
  {key:&quot;d&quot;, value:1.5},
  {key:&quot;e&quot;, value:.7},
  {key:&quot;f&quot;, value:.3}
];

pv.max(data, function(a) a.value); // should return 1.7</pre>
<h4>pv.sum(), pv.mean(), pv.median()</h4>
<p>Likewise, protovis has aptly-named methods that return the sum, the mean and the median of the elements of an array. Note that it&#8217;s pv.mean() and not pv.average(), though.</p>
<pre class="brush: jscript; title: ; notranslate">pv.sum([1, 1.2, 1.7, 1.5, .7, .3]) // gives  6.4.
pv.mean([1, 1.2, 1.7, 1.5, .7, .3]) // gives 1.0666666666666667
pv.median([1, 1.2, 1.7, 1.5, .7, .3]) // gives 1.1.</pre>
<p>Similarly to pv.min() you can use an optional accessor function.</p>
<pre class="brush: jscript; title: ; notranslate">pv.median(data, function(a) a.value);</pre>
<h4>pv.normalize()</h4>
<p>pv.normalize() is a handy method that divides all elements in an array by a factor, so that the sum of all these elements is 1.</p>
<pre class="brush: jscript; title: ; notranslate">pv.normalize([1, 1.2, 1.7, 1.5, .7, .3])
// [0.15625, 0.18749999999999997, 0.265625, 0.234375, 0.10937499999999999, 0.04687499999999999]

pv.sum(pv.normalize([1, 1.2, 1.7, 1.5, .7, .3])) // result: 1.</pre>
<h3>Combining arrays</h3>
<h4>pv.blend()</h4>
<p>pv.blend() simply turns an array of arrays into a simpler array where all elements follow each other.</p>
<pre class="brush: jscript; title: ; notranslate">pv.blend([[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [1,2,3]]) // gives  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 1, 2, 3]</pre>
<p>One benefit is that it is possible to run methods on this new array that wouldn’t work on an array of arrays.</p>
<p>For instance:</p>
<pre class="brush: jscript; title: ; notranslate">pv.max([[1,2],[3,4],[5,6]]) // result : NaN
// protovis cannot guess how to compare [1,2], [3,4] or [5,6] without any further instruction.
pv.max(pv.blend([[1,2],[3,4],[5,6]])) // result: 6.
pv.max([[1,2],[3,4],[5,6]], function(a) pv.max(a)) // also returns 6.</pre>
<h4>pv.cross()</h4>
<p>Given two arrays a and b, pv.cross(a,b) returns an array of all possible pairs of elements.</p>
<pre class="brush: jscript; title: ; notranslate">pv.cross([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [1,2,3]) // returns 
//[[“a”,1],[“a”,2],[“a”,3],[“b”,1],[“b”,2],[“b”,3],[“c”,1],[“c”,2],[“c”,3]]</pre>
<h4>pv.transpose()</h4>
<p>pv.transpose() flips an array of arrays.</p>
<p>In our previous example –</p>
<pre class="brush: jscript; title: ; notranslate">pv.cross([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [1,2,3])</pre>
<p>The result was a 9&#215;2 array. [[“a”,1],[“a”,2],[“a”,3],[“b”,1],[“b”,2],[“b”,3],[“c”,1],[“c”,2],[“c”,3]]</p>
<p>If we apply pv.transpose, we get a 2&#215;9 array:</p>
<pre class="brush: jscript; title: ; notranslate">pv.transpose(pv.cross([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [1,2,3])); // result:
//[[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]
//[1,2,3,1,2,3,1,2,3]]</pre>
<h3>Putting it all together</h3>
<p>This short example will show how one can work from an unprepared dataset.<br />
For the purpose of this example, I&#8217;m retrieving GDP per capita data of OECD countries. I have a table of 34 countries on 10 years from 2000 to 2009. The countries are in alphabetical order.<br />
I would like to do a bar chart showing the top 12 countries ranked by their GDP per capita. How complex can this be? With the array methods, not so difficult.</p>
<pre class="brush: jscript; highlight: [40,50]; title: ; notranslate">var data=[
[&quot;Country&quot;,2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009],
[&quot;Australia&quot;,28045.6566279103, 29241.289462815, 30444.7839453338, 32079.5610505727, 33494.6654789274, 35091.7414600449, 37098.3968669994, 39002.0335375021, 39148.4759391917, 39660.1953738791],
[&quot;Austria&quot;,28769.5911274323, 28799.1968990511, 30231.0955219759, 31080.6122212092, 32598.0698959222, 33409.3453751649, 36268.9604225683, 37801.7320979073, 39848.9481928628, 38822.6960085478],
[&quot;Belgium&quot;,27624.4454637489, 28488.7963954409, 30013.7570016445, 30241.724380444, 31151.6315179167, 32140.9239149283, 34159.4723388042, 35597.2980660662, 36878.9710906881, 36308.4784216699],
[&quot;Canada&quot;,28484.9776553362, 29331.8223245112, 29911.3226371905, 31268.5521058006, 32845.6267954986, 35105.9892865177, 36853.5554314586, 38353.0812084648, 38883.0700787846, 37807.5259929247],
[&quot;Chile&quot;,9293.72322249492, 9712.95685376592, 9973.25946014534, 10475.6486664294, 11299.9329380664, 12194.1443507847, 13036.1285137662, 13896.6946083854, 14577.5715215544, 14346.4648487517],
[&quot;Czech Republic&quot;,14992.3582327884, 16173.6387263985, 16872.3146139754, 17991.9331910401, 19303.9208098529, 20365.7571142986, 22349.7033747705, 24578.7151794413, 25845.0252652635, 25530.2001372786],
[&quot;Denmark&quot;,28822.3343389384, 29437.5232757263, 30756.3323835463, 30427.5149228283, 32301.3394496912, 33195.8834383121, 36025.8628586246, 37730.736916861, 39494.1216134705, 37688.2516868117],
[&quot;Estonia&quot;,9861.80346448344, 10693.0362387373, 11966.6746413277, 13370.127724177, 14758.4181995435, 16530.7311083966, 19134.4130457855, 21262.1415030861, 21802.2185996096, 19880.2786070771],
[&quot;Finland&quot;,25651.0005450286, 26518.293212524, 27509.1023963486, 27592.2031438268, 29855.387224753, 30689.9753400459, 33095.030855128, 36149.32963148, 37795.237097856, 35236.9462175119],
[&quot;France&quot;,25272.4127936247, 26644.8404266553, 27776.4225007831, 27399.5459524877, 28273.6330332193, 29692.129719144, 31551.3458452695, 33300.5367942194, 34233.0770304046, 33697.9698933558],
[&quot;Germany&quot;,25949.0588445755, 26855.1296905696, 27587.1573355486, 28566.8930562768, 29900.6507502683, 31365.576121107, 33713.1689185469, 35623.4147543745, 37170.693412872, 36339.9009091421],
[&quot;Greece&quot;,18410.2161113813, 19928.6672542964, 21597.5997816753, 22701.7754699285, 24088.2202877303, 24571.6085727425, 26917.7358531616, 28059.5724529461, 29919.6385697499, 29121.8306842272],
[&quot;Hungary&quot;,12134.0140204384, 13576.4413471795, 14765.2333755651, 15424.3926636975, 16316.8885518624, 16937.9383138957, 18329.1579647528, 19187.2829138188, 20699.9056965458, 20279.5060192879],
[&quot;Iceland&quot;,28840.4899286393, 30443.907492292, 31083.7723760522, 30768.0910155965, 33697.6723843766, 35025.1338769129, 35807.880160537, 37178.9762849327, 39029.2396691797, 36789.0728215933],
[&quot;Ireland&quot;,28695.0931156375, 30524.3712319885, 33052.4517849575, 34525.4148515126, 36511.518217243, 38622.5520655621, 42267.9784043449, 45293.6482834027, 42643.6362934458, 39571.204030073],
[&quot;Israel&quot;,23496.1573531847, 23455.1048827219, 23534.8524310529, 22270.5507137525, 23650.3373360675, 23390.3809761211, 24960.0508863672, 26583.387317862, 27679.3777353666, 27661.1271269539],
[&quot;Italy&quot;,25594.3456589799, 27127.4298830414, 26803.97019843, 27137.5365317475, 27416.0961790796, 28144.0379218171, 30224.2469223694, 31897.7434207435, 33270.7464832409, 32407.5033618371],
[&quot;Japan&quot;,25607.7204586644, 26156.1615068187, 26804.9303541079, 27487.123875677, 29020.8955443678, 30311.5281317716, 31865.2733339475, 33577.1846704038, 33902.3807335349, 32476.7736535378],
[&quot;Korea&quot;,17197.0800334388, 18150.876787578, 19655.5961579558, 20180.932195274, 21630.1629926488, 22783.2288432845, 24286.1803272315, 26190.6122298674, 26876.6422899926, 27099.9481192024],
[&quot;Luxembourg&quot;,53645.7229595775, 53932.4594967082, 57559.2104243171, 60723.9861616145, 65021.6940738929, 68372.258619455, 78523.2988291034, 84577.2190776183, 89732.070876649, 84802.9716853677],
[&quot;Mexico&quot;,10046.1268819126, 10135.7265293228, 10397.8915415223, 10883.8643666506, 11535.0108530091, 12460.5385178945, 13672.6034191998, 14581.5178679935, 15290.896575069, 14336.6153896301],
[&quot;Netherlands&quot;,29405.5490140191, 30788.2508953647, 31943.4974056501, 31702.5798119046, 33208.8592768987, 35110.6577619843, 38063.6877336725, 40744.3819227526, 42887.4361825772, 40813.047575264],
[&quot;New Zealand&quot;,21113.9167562199, 22128.8483527737, 23115.0676326844, 23826.8007737809, 24775.7827578032, 25460.2942993256, 27277.7654223562, 28701.3328788203, 29231.151567007, 29097.307061683],
[&quot;Norway&quot;,36125.7036078917, 37091.7150478501, 37051.9473705873, 38298.8631304819, 42257.5943785044, 47318.7844737929, 53287.9750020125, 55042.2093246253, 60634.9819502298, 55726.7456848212],
[&quot;Poland&quot;,10567.0016558591, 10950.4739587211, 11562.6245018264, 11985.0042955849, 13014.5996003514, 13785.7656450352, 15067.4402978586, 16762.2045951617, 18062.1834289945, 18928.8205162032],
[&quot;Portugal&quot;,17748.6930918065, 18464.7472033934, 19088.1764760703, 19392.2862101711, 19796.1891048601, 21294.1660710906, 22869.9272824917, 24122.9886840593, 24962.2959136026, 24980.061318413],
[&quot;Slovak Republic&quot;,10980.1169029929, 12070.70145551, 12965.6228450353, 13597.9556337584, 14659.0096334623, 16174.4605836956, 18397.5822518716, 20916.5438777989, 23241.0972994031, 22870.8998469728],
[&quot;Slovenia&quot;,17468.5101911515, 18342.8685005009, 19702.0589885459, 20448.2040741134, 22200.7770986247, 23493.9370882038, 25432.3240768864, 27228.3376725332, 29240.5471362484, 27535.6540786883],
[&quot;Spain&quot;,21320.0690041202, 22591.3855327033, 24066.5003000439, 24748.2819467008, 25958.1017090553, 27376.7644983649, 30347.9357063518, 32251.8469529105, 33173.3334547015, 32254.0895139806],
[&quot;Sweden&quot;,27948.4749835611, 28231.3958224236, 29277.7736264795, 30418.0441004337, 32505.646687298, 32701.4327422078, 35680.1787996674, 38339.6698693908, 39321.3014501815, 36996.1394001578],
[&quot;Switzerland&quot;,31618.0958082618, 32103.4812665805, 33390.9169108411, 33266.3042144918, 34536.8476164193, 35478.0395058126, 39116.3945212067, 42755.5569054368, 45516.5601956426, 44830.3719226918],
[&quot;Turkey&quot;,9169.71780977686, 8613.21159842998, 8666.90348260238, 8790.01048446305, 10166.0963401732, 11391.3768057053, 12886.6195973915, 13897.3820310325, 14962.4944915831, 14242.7276329837],
[&quot;United Kingdom&quot;,26071.3066882302, 27578.2857038985, 28887.5850874466, 29848.7319363944, 31790.9933025905, 32724.4057819337, 34970.5193042987, 35719.2060247462, 36817.493156774, 35158.8005888247],
[&quot;United States&quot;,35050.1738557741, 35866.2624634202, 36754.5543204007, 38127.524970345, 40246.0630591955, 42466.1326203714, 44594.9199470326, 46337.2237397566, 46901.0697730874, 45673.7445647402]
];

var year=10;
var rows = data.slice(1,data.length);

var x = pv.Scale.ordinal(pv.range(12)).splitBanded(0, 240, 4/5);
var y = pv.Scale.linear(0, 80000).range(0, 170);

var vis = new pv.Panel()
    .width(250)
    .height(200)
    ;
	vis.add(pv.Bar)
		.data(rows.sort(function(a,b) b[year]-a[year]).slice(0,12))
		.bottom(10)
		.width(x.range().band)
		.height(function(d) y(d[year]))
		.left(function() 5+x(this.index))
		.anchor(&quot;bottom&quot;).add(pv.Label).textAngle(Math.PI/2).text(function(d) d[0]).textBaseline(&quot;middle&quot;).textAlign(&quot;right&quot;)
		;
vis.render();</pre>
<p>here, in the data variable, I&#8217;ve put my 2-dimensional table as I got it. The first row contains headers which I won&#8217;t need. So, in line 40, I create rows which just removes that 1st line with a slice function. data.slice(1,data.length) effectively keeps all the lines but the first.<br />
In the next few lines I create two scales for placing my bars, a standard vis panel and a bar chart. Now, what kind of data will I pass to the bar chart?<br />
I want to sort the rows by the value of the latest year (which happens to be the 11th column, so 10). This is what the rows.sort(function(a,b) b[year]-a[year]) part of the statement does. I&#8217;ve simply assigned 10 to the variable year, so if I want to display other years (with an HTML form for instance) it wouldn&#8217;t be difficult to modify.<br />
And, since I only want the top 12 values, I just write .slice(0,12) after that. </p>
<p>In line 55, I just add a label. pv.Label inherits the data of its parent. The data item is the whole row of my 2-dimensional table, so if I write function(d) d[0], I am referring to the left-most item which will be the country name. </p>
<p>So, with the use of simple array functions, I can easily rework an unprepared dataset in protovis, rather than having to tailor my dataset with manual (and error-prone) manipulations in external programs. Here is the result:<br />
<a href="http://jckr.github.io/blog/wp-content/uploads/2011/02/sortedBar.png"><img src="https://jckr.github.io/blog/wp-content/uploads/2011/02/sortedBar.png" alt="" title="sortedBar" width="250" height="200" class="aligncenter size-full wp-image-589" /></a><br />
Next: <a href="http://jckr.github.io/blog/?p=502">reshaping complex arrays</a></p>
]]></content:encoded>
			<wfw:commentRss>/2011/02/09/working-with-data-in-protovis-part-3-of-5/feed/</wfw:commentRss>
		<slash:comments>6</slash:comments>
		</item>
		<item>
		<title>Working with data in protovis &#8211; part 1 of 5</title>
		<link>/2011/02/07/working-with-data-in-protovis-part-1-of-5/</link>
		<comments>/2011/02/07/working-with-data-in-protovis-part-1-of-5/#comments</comments>
		<pubDate>Mon, 07 Feb 2011 17:41:46 +0000</pubDate>
		<dc:creator><![CDATA[jerome]]></dc:creator>
				<category><![CDATA[data visualization]]></category>
		<category><![CDATA[protovis]]></category>
		<category><![CDATA[tips]]></category>
		<category><![CDATA[arrays]]></category>
		<category><![CDATA[data]]></category>
		<category><![CDATA[tutorial]]></category>

		<guid isPermaLink="false">http://jckr.github.io/blog/?p=429</guid>
		<description><![CDATA[When I started using protovis I had only a very basic knowledge of javascript, which in theory isn’t a problem as protovis is meant to be learned by example, and as it has its own logic and structure which is different from typical javascript code. So I started by looking and modifying examples which was <a class="read-more" href="/blog/2011/02/07/working-with-data-in-protovis-part-1-of-5/">&#8230;&#160;<span class="meta-nav">&#8594;</span></a>]]></description>
				<content:encoded><![CDATA[<p>When I started using <a href="http://www.protovis.org/">protovis </a>I had only a very basic knowledge of javascript, which in theory isn’t a problem as protovis is meant to be learned by example, and as it has its own logic and structure which is different from typical javascript code. So I started by looking and modifying examples which was enough to do basic stuff.<br />
But I soon felt limited by what hid behind a single property: <strong>data</strong>. I knew that protovis had lots of features to manipulate and process data but they were not obvious from the examples.</p>
<p>I mean,</p>
<table border="0" cellpadding="0" width="640">
<tbody>
<tr>
<td>
<pre class="brush: jscript; title: ; notranslate">var vis = new pv.Panel()
.width(150)
.height(150);

vis.add(pv.Bar)
.data([1, 1.2, 1.7, 1.5, .7, .3])
.width(20)
.height(function(d) d * 80)

vis.render();</pre>
</td>
<td><a href="http://jckr.github.io/blog/wp-content/uploads/2011/01/basic-example1.png"><img class="aligncenter size-full wp-image-433" title="basic example" src="https://jckr.github.io/blog/wp-content/uploads/2011/01/basic-example1.png" alt="" width="150" height="150" /></a></td>
</tr>
</tbody>
</table>
<p>Here, it’s pretty obvious that the bars represent the values 1, 1.2, 1.7, 1.5, 0.7 and 0.3 respectively. One can infer that the sizes of bars are 25 pixels wide and 80 times their value long.</p>
<p>But protovis doesn’t usually look like this “hello world” kind of example, but rather like this:</p>
<pre class="brush: jscript; title: ; notranslate">
/* Compute yield medians by site and by variety. */
function median(data) pv.median(data, function(d) d.yield);
var site = pv.nest(barley).key(function(d) d.site).rollup(median);
var variety = pv.nest(barley).key(function(d) d.variety).rollup(median);
/* Nest yields data by site then year. */
barley = pv.nest(barley)
    .key(function(d) d.site)
    .sortKeys(function(a, b) site[b] - site[a])
    .key(function(d) d.year)
    .sortValues(function(a, b) variety[b.variety] - variety[a.variety])
    .entries();
[. . .]
/* A panel per site-year. */
var cell = vis.add(pv.Panel)
    .data(barley)
    .height(h)
    .top(function() this.index * h)
    .strokeStyle(&quot;#999&quot;);</pre>
<p>What just happened? <a href="http://vis.stanford.edu/protovis/jsdoc/symbols/pv.Nest.html">pv.nest</a>, key, rollup, sortKeys, entries – what could that do?</p>
<p>To go beyond merely touching up examples, and do your own visualizations from scratch, it is important to get a good grip on how to feed protovis with data. In order to do so, you need a few javascript notions.</p>
<h2>Arrays, arrays, how do they work?</h2>
<p>In javascript, an array is an ordered list of stuff.</p>
<p>In our initial example, we had one such list:</p>
<pre class="brush: jscript; light: true; title: ; notranslate">[1, 1.2, 1.7, 1.5, .7, .3]</pre>
<p>Anything can be put in an array: numbers, strings, Booleans (true/false values), objects … including other arrays. All elements of an array don’t have to be of the same type. Arrays can be assigned to a variable.</p>
<pre class="brush: jscript; light: true; title: ; notranslate">var a = [1, 1.2, 1.7, 1.5, .7, .3];</pre>
<p>Elements of the array can be accessed using the [] notation. In javascript, indices start at 0, so the first element of an array can be obtained so:</p>
<pre class="brush: jscript; light: true; title: ; notranslate">a[0];</pre>
<p>This returns 1. Javascript has many functions to create and manipulate arrays, which we will talk about later. For the time being, let’s look at arrays of arrays. If we wrote instead:</p>
<pre class="brush: jscript; light: true; title: ; notranslate">var a = [[1, 1.2], [1.7, 1.5], [.7, .3]];</pre>
<p>a is now an array of arrays, or “multi-dimensional array”.</p>
<p>a[0] is now worth [1, 1.2]. To access the first number of the array, one has to write a[0][0], which will return the first element (1) of the first element ([1, 1.2]) of a.</p>
<p>Javascript also has another type of array called associative arrays, where values are assigned to keys instead of an index. For instance,</p>
<pre class="brush: jscript; light: true; title: ; notranslate">var a = {yield: 27.00000, variety: &quot;Manchuria&quot;, year: 1931, site: &quot;University Farm&quot;};</pre>
<p>is an associative array. To access a value, one can use a . operator:</p>
<pre class="brush: jscript; light: true; title: ; notranslate">a.yield</pre>
<p>will retun 27.</p>
<pre class="brush: jscript; light: true; title: ; notranslate">a[&quot;yield&quot;]</pre>
<p>also works.</p>
<p>Like other variable types, it is possible to have an array of associative arrays. In fact, this is used quite often in protovis.</p>
<h2>Protovis and arrays – deconstructing the first example</h2>
<p>The reason why I introduced javascript arrays is that the data property <span style="text-decoration: underline;">requires an array</span>. Protovis then loops through that array, performing operations on each of its elements. To that end, it uses things such as accessor functions and properties of an object called this.</p>
<p>To explain all of this let’s go back to the first example and analyse it line by line.</p>
<pre class="brush: jscript; title: ; notranslate">var vis = new pv.Panel()
  .width(150)
  .height(150);
vis.add(pv.Bar)
  .data([1, 1.2, 1.7, 1.5, .7, .3])
  .width(20)
  .bottom(0)
  .height(function(d) d * 80)
  .left(function() this.index * 25);
vis.render();</pre>
<p>The first 3 lines create a panel, which is like the sheet of paper on which protovis will draw the chart. Its width and height properties must be filled, as they are 0 by default which would make the whole visualization invisible.</p>
<p>The next line adds a bar chart to this panel we’ve just created.</p>
<p>The line after specifies the data on which to work: here comes our array. Here, we have written the array literally in the data property, but nothing prevents us to assign it to a variable first and to pass the variable instead.</p>
<p>The next line, and the line with the bottom property, assign constant numbers to these properties. It means that all the bars will have a width of 20 pixels, and they will all be aligned with the bottom of the panel – that’s what</p>
<pre class="brush: jscript; first-line: 7; title: ; notranslate">bottom(0)</pre>
<p>does.</p>
<p>Now let’s look at the two remaining lines:</p>
<pre class="brush: jscript; first-line: 8; title: ; notranslate">.height(function(d) d * 80)
.left(function() this.index * 25);</pre>
<p>The first line uses an accessor function. What this does is that it looks at the current element, and perform an operation on it, the result of which will be the height of that element.</p>
<p>In proper javascript, we would have written:</p>
<pre class="brush: jscript; light: true; title: ; notranslate">function(d) {return d*80;}</pre>
<p>but protovis uses a shorthand notation that allows us to omit curly braces and the return statement. By the way, d in the function is completely arbitrary, and could be any variable name –</p>
<pre class="brush: jscript; light: true; title: ; notranslate">function(a) a*80</pre>
<p>also works. It’s just that the name of the variable between parentheses will represent the value of the current element.</p>
<p>The second line uses the this object. this represents what protovis is working on at the moment, and it has properties that can be used. The most commonly used is index: this.index returns the position of the current element in its array, so it is going to be: 0 for the first bar, 1 for the next one, etc.</p>
<p>So this line specifies that each new bar should start every 25 pixels from the left border of the panel.</p>
<p>You may wonder, why not write</p>
<pre class="brush: jscript; light: true; title: ; notranslate">.left(this.index * 25);</pre>
<p>and omit the function()? Well, function() means that the content of the property gets re-evaluated. If we had omitted it, this.index * 25 would have been computed once (for a result of 0) and that value would have been used for all the bars.</p>
<p>By the way, instead of writing the height property as it is, we could have written:</p>
<pre class="brush: jscript; light: true; title: ; notranslate">.height(function()[1, 1.2, 1.7, 1.5, .7, .3][this.index] * 80)</pre>
<p>Using an accessor function is shorter and clearer.</p>
<p>Next: <a href="http://jckr.github.io/blog/?p=479">Multi-dimensional arrays, inheritance and hierarchy</a></p>
]]></content:encoded>
			<wfw:commentRss>/2011/02/07/working-with-data-in-protovis-part-1-of-5/feed/</wfw:commentRss>
		<slash:comments>11</slash:comments>
		</item>
	</channel>
</rss>
